# EMV2 错误模型与图形编辑器设计

本文档基于源码分析，描述 OSATE2 的 EMV2（Error Model V2）子系统和图形编辑器（GE）的设计。

## Part A：EMV2 错误模型

### 1. EMV2 语法结构

EMV2 使用 Xtext 定义在 `emv2/org.osate.xtext.aadl2.errormodel/src/.../ErrorModel.xtext`，作为 AADL Annex 子语言集成。

#### 1.1 顶层结构

```xtext
EMV2Root:
    EMV2Library | EMV2Subclause[]

ErrorModelLibrary:    — 可复用的错误模型库
    ├── ErrorType[]          — 错误类型定义（支持继承 extends 和别名 renames）
    ├── TypeSet[]            — 错误类型集合（如 {HardwareFailure, SoftwareFailure}）
    ├── ErrorBehaviorStateMachine[]  — 错误行为状态机
    ├── TypeMappingSet[]     — 类型映射集
    └── TypeTransformationSet[]     — 类型转换集

ErrorModelSubclause:  — 附加到 AADL 组件的错误规格
    ├── ErrorPropagation[]   — 错误传播声明
    ├── ErrorFlow[]          — 错误流（Source/Sink/Path）
    ├── ErrorBehaviorTransition[] — 状态转换
    ├── OutgoingPropagationCondition[] — 出站传播条件
    ├── ErrorDetection[]     — 错误检测
    ├── CompositeState[]     — 组合错误行为
    └── PropagationPath[]    — 传播路径
```

#### 1.2 错误类型系统

```
ErrorType — 基本错误类型
├── name: String
├── superType → ErrorType (可选，支持继承)
└── aliased → ErrorType (可选，重命名别名)

TypeSet — 错误类型集合
├── name: String
└── typeTokens: TypeToken[] (联合语义)

TypeToken — 类型集构造器
└── type: ErrorType[] (用 * 运算符组合为乘积类型)
```

**设计要点**：
- 层次化类型定义，支持继承（type extension）
- 类型别名支持向后兼容
- TypeSet 支持联合语义
- TypeToken 的乘积类型支持错误组合建模

#### 1.3 错误传播与流

```
ErrorPropagation — 错误传播声明
├── direction: PropagationDirection (in | out)
├── featureorPPRef → FeatureorPPReference  — 绑定到 AADL 特征/传播点
├── typeSet → TypeSet                       — 约束传播的错误类型
└── not: boolean                            — 否定传播（noerror 情况）

ErrorFlow (abstract)
├── ErrorSource — 错误产生源
│   ├── sourceModelElement → NamedElement
│   ├── failureModeReference → ErrorBehaviorState
│   ├── typeTokenConstraint → TypeSet
│   └── flowCondition → IfCondition (STRING/Resolute/Java)
│
├── ErrorSink — 错误终止点
│   └── incoming → ErrorPropagation (带类型约束)
│
└── ErrorPath — 错误转换路径
    ├── incoming/outgoing → ErrorPropagation
    ├── typeMappingSet → TypeMappingSet
    └── targetToken → TypeToken (直接类型映射)
```

#### 1.4 错误行为状态机

```
ErrorBehaviorStateMachine
├── states: ErrorBehaviorState[]
│   ├── name: String
│   ├── initial: boolean
│   └── typeSet → TypeSet (可选状态类型约束)
│
├── events: ErrorBehaviorEvent[]
│   ├── ErrorEvent — 错误事件
│   ├── RepairEvent — 修复事件
│   └── RecoverEvent — 恢复事件
│
└── transitions: ErrorBehaviorTransition[]
    ├── source → ErrorBehaviorState | all
    ├── condition → ConditionExpression
    └── target → ErrorBehaviorState | same state | Branch[]（概率分支）
```

#### 1.5 条件表达式

```
ConditionExpression (布尔代数)
├── AND, OR — 基本逻辑运算
├── AllExpression — 全部满足
├── OrmoreExpression — N-of-M（至少 N 个满足）
├── OrlessExpression — 至多 N 个满足
└── ConditionElement — 引用事件或入站传播（带类型约束）
```

#### 1.6 组合错误行为

```
CompositeState — 系统级状态（基于子组件错误状态）
├── state → ErrorBehaviorState
└── condition → 子组件状态条件表达式

OutgoingPropagationCondition — 基于内部状态决定出站错误
├── state → ErrorBehaviorState | allStates
├── condition → ConditionExpression
└── outgoing → ErrorPropagation | all propagations | noerror
```

### 2. 错误模型实例化

`EMV2AnnexInstantiator` 将文本错误规格转换为运行时实例模型。

#### 2.1 实例化流水线

```
对每个组件实例（ComponentInstance）:
1. 提取所有 ErrorModelSubclause
2. 获取行为状态机
3. 创建 EMV2AnnexInstance（根容器）
   │
   ├── 4. 传播点实例化
   │   └── PropagationPointInstance
   │
   ├── 5. 错误传播实例化
   │   ├── FeaturePropagation
   │   ├── AccessPropagation
   │   ├── PointPropagation
   │   └── BindingPropagation
   │   └── 匿名类型集解析（AnonymousTypeSet + TypeInstance）
   │
   ├── 6. 错误事件实例化
   │   ├── ErrorEventInstance
   │   ├── RepairEventInstance
   │   └── RecoverEventInstance
   │
   ├── 7. 状态实例化
   │   └── StateInstance（标记 initial 状态）
   │
   ├── 8. 转换实例化
   │   └── TransitionInstance
   │       ├── source: SourceStateReference | AllSources
   │       ├── condition: ConditionExpressionInstance
   │       └── destination: DestinationStateReference | SameState | Branches
   │
   ├── 9. 出站传播条件实例化
   │   └── OutgoingPropagationConditionInstance
   │
   └── 10. 检测实例化
       └── DetectionInstance（错误码: IntegerCode/StringCode/ConstantCode）

对 SystemInstance（系统级）:
  ├── 11. 连接路径实例化（ConnectionPath）
  └── 12. 绑定路径实例化（BindingPath: processor/memory/connection/binding）
```

#### 2.2 关键实例类

| 类 | 职责 |
|----|------|
| `EMV2AnnexInstance` | 根容器（extends AnnexInstance） |
| `AbstractTypeSet` | 类型集基类，提供 `flatten()` 操作 |
| `TypeSetInstance` | 引用命名类型集 |
| `AnonymousTypeSet` | 内联类型定义 |
| `TypeInstance` | 单个类型实例 |
| `TypeProductInstance` | 乘积类型实例 |
| `TransitionInstance` | 转换实例（源/条件/目标） |
| `CompositeConditionExpression` | 复合条件求值基类 |

### 3. 传播图模型

定义在 `emv2/org.osate.aadl2.errormodel.propagationgraph/model/PropagationGraph.ecore`。

```
PropagationGraph — 错误传播拓扑视图
├── components: ComponentInstance[]
├── paths: PropagationGraphPath[]
│   ├── source/destination: PropagationPathEnd
│   │   ├── componentInstance → ComponentInstance
│   │   ├── errorPropagation → ErrorPropagation
│   │   └── connectionInstance → ConnectionInstance (可选)
│   └── type: PropagationType (connection | binding | userDefined)
└── connections: ConnectionInstance[]
```

**生成方式**：`Util.generatePropagationGraph(root, false)` 从实例模型自动构建。

### 4. 故障树生成算法

`FTAGenerator` 通过反向遍历从系统级错误状态追溯故障链。

#### 4.1 算法概览

```
1. 根选择：用户选择顶层故障（错误状态或传播）

2. 反向遍历（PropagationGraphBackwardTraversal）:
   ├── 从选中的错误状态/传播出发
   ├── 反向追踪错误路径和 Sink
   ├── 展开入站错误的条件
   └── 递归处理子组件

3. 事件层次构建:
   ├── FaultTree（根 Event）
   ├── Event 类型: Basic (叶节点故障) | External | Undeveloped | Intermediate (门)
   └── SubEventLogic: OR | AND | XOR | PriorityAnd | kOf | kOrmore | kOrless

4. 门优化:
   ├── flattenGates()    — 合并同类嵌套门
   ├── cleanupXORGates() — 移除单事件 XOR 门
   ├── optimizeGates()   — 最小化事件树
   └── minimalCutSet()   — 计算最小割集

5. 概率计算:
   ├── fillProbabilities()    — 分配/计算概率
   └── computeProbabilities() — 基于门类型递归聚合概率
```

#### 4.2 故障树类型

| 类型 | 说明 |
|------|------|
| **FaultTree** | 优化后的树，门已扁平化 |
| **FaultTrace** | 保留完整路径细节的反向追踪 |
| **CompositeParts** | 仅显示直接贡献者，不展开 |
| **MinimalCutSet** | 最小割集表示，用于 MCS 分析 |

#### 4.3 错误影响分析

`PropagateErrorSources` 类执行正向错误影响分析：
- 从错误源出发，前向追踪影响范围
- 支持可配置的最大追踪深度（默认 7 级）
- 生成 CSV 格式的影响报告
- 使用 `visited` 集合避免循环追踪
- 使用 `alreadyTreated` 缓存避免重复处理

### 5. EMV2 分析链总结

```
AADL 文本 (annex error_model {** ... **})
    ↓ AnnexParserAgent → EMV2AnnexParser
ErrorModel Ecore 模型
    ↓ EMV2AnnexInstantiator
EMV2AnnexInstance (实例模型)
    ↓ Util.generatePropagationGraph()
PropagationGraph (传播拓扑)
    ↓ FTAGenerator / PropagateErrorSources
FaultTree / 影响报告
    ↓ 优化 + 概率计算
分析结果（Markers + 报告）
```

---

## Part B：图形编辑器（GE）

### 6. 编辑器架构

GE 使用多层架构，关注点清晰分离：

```
Business Object Layer — 领域模型（AADL/EMV2/BA 元素）
    ↓
Diagram Runtime (AgeDiagram) — 内存中图表表示
    ↓
Diagram Rendering (GefAgeDiagram) — JavaFX 场景图生成
    ↓
UI Layer (AgeEditor) — Eclipse 编辑器集成
```

### 7. Business Object Handler 模式

核心设计模式——所有可见元素都是"业务对象"（BO）。

#### 7.1 Handler 接口

```java
BusinessObjectHandler {
    isApplicable(ctx) → boolean           // 是否管理此 BO
    getCanonicalReference(ctx)            // 永久标识符（从模型根的路径）
    getRelativeReference(ctx)             // 父级相对标识符（用于持久化）
    getGraphicalConfiguration(ctx)        // 视觉表示：形状、颜色、标签、连接
    getName(ctx) → String                 // UI 显示名称
    getNameForDiagram(ctx) → String       // 图中标签文本
    canRename() / validateName()          // 重命名能力与验证
    canDelete() / canCopy()               // 编辑能力
    getIconId(ctx)                        // 大纲视图图标
}
```

#### 7.2 注册与发现

- 通过扩展点注册：`org.osate.ge.businessObjectHandlers`
- **BusinessObjectProvider**：为给定上下文贡献子 BO
- 注册扩展点：`org.osate.ge.businessObjectProviders`
- 多个 Handler 可竞争，第一个匹配者胜出

#### 7.3 领域特定 Handler

| Handler | 覆盖范围 |
|---------|---------|
| AADL Handler (`org.osate.ge.aadl2`) | 组件、特征、连接、流、模式 |
| BA Handler (`org.osate.ge.ba`) | 行为附件可视化 |
| EMV2 Handler (`org.osate.ge.errormodel`) | 错误传播图 |

### 8. 图表数据模型

定义在 `ge/org.osate.ge/model/diagram.ecore`。

```
Diagram
├── formatVersion: int (当前: 7)
├── config: DiagramConfiguration
│   ├── type: String (图表类型 ID)
│   ├── context: CanonicalBusinessObjectReference (根 BO)
│   ├── enabledAadlProperties: String[] (显示的属性)
│   └── connectionPrimaryLabelsVisible: Boolean
│
└── element[*]: DiagramElement (树结构)

DiagramElement
├── uuid: String (图内唯一标识)
├── bo: RelativeBusinessObjectReference (引用的业务对象)
├── position: Point (x, y)
├── size: Dimension (width, height)
├── dockArea: String (停靠区域)
├── bendpoints: Point[] (连接弯折点)
├── primaryLabelPosition: Point
├── background/outline/fontColor: Color (样式覆盖)
├── fontSize/lineWidth: Double
├── primaryLabelVisible: Boolean
├── image: String (自定义图片引用)
└── showAsImage: Boolean
```

**序列化**：XMI 格式，UUID 标识元素，相对引用确保可移植性。

### 9. 双向同步机制

#### 9.1 读取图表

```
加载 XMI 文件 → EMF ResourceSet 解析
    → 迁移旧版 ID 到 UUID
    → 转换为运行时 AgeDiagram
    → 从相对引用实例化业务对象
```

#### 9.2 模型到图表同步

```
AADL 模型变更 → BusinessObjectTreeUpdater → DiagramUpdater → AgeDiagram → 场景图
                                                  ↓
                                        BusinessObjectProvider/Handler
```

**更新流水线**：
1. **DiagramToBusinessObjectTreeConverter**：从当前图表构建 BO 树
2. **BusinessObjectTreeUpdater**：基于 Handler 和 Provider 展开树
   - 添加 Provider 发现的新子 BO
   - 维护 BO 类型映射
3. **DiagramUpdater**：协调树与图表元素
   - 为新 BO 创建元素
   - 为移除的 BO 创建"幽灵元素"（保留布局）
   - 更新图形配置

#### 9.3 关键特性

| 特性 | 说明 |
|------|------|
| **Ghost Elements** | 隐藏元素保留布局，便于后续恢复 |
| **Future Elements** | 为正在创建的元素预分配位置 |
| **ReferenceResolutionService** | 解析相对引用到 BO 实例 |
| **ReferenceBuilderService** | 重建规范引用 |

### 10. 渲染与布局策略

#### 10.1 渲染流水线

```
AgeDiagram 变更事件
    ↓ DiagramModificationListener
场景节点创建/修改
    ├── GefDiagramElement (元数据)
    ├── sceneNode (JavaFX Node)
    └── primaryLabel (LabelNode)
    ↓
StyleCalculator (配置 → 渲染器无关 Style)
    ↓
StyleToFx (Style → JavaFX FxStyle)
    ↓
FxStyleApplier (FxStyle → JavaFX 节点)
    ↓
场景图更新
```

#### 10.2 场景节点类型

| 节点类型 | 用途 |
|---------|------|
| `DiagramRootNode` | 所有形状和连接的容器 |
| `ContainerShape` | 组件的复合形状 |
| `DockedShape` | 停靠到容器边缘的形状 |
| `ConnectionNode` | 带弯折点的连接 |
| `LabelNode` | 带样式的文本标签 |
| `FeatureGroupNode` | 特征组的圆形标记 |
| `FlowIndicatorNode` | 流指示器 |
| `ImageNode` | 自定义图片 |

#### 10.3 布局系统

- **Position**：绝对或相对于父级
- **DockArea**：停靠侧（TOP, BOTTOM, LEFT, RIGHT）
- **Bendpoints**：连接路由点
- **ELK 集成**：自动布局引擎（AgeLayoutOptions）
- 支持手动定位与自定义样式

### 11. UI 编辑器集成

```
AgeEditor (Eclipse EditorPart)
├── FXCanvas — 嵌入 JavaFX 场景到 SWT
├── Scene Graph — JavaFX Group 包含 DiagramRootNode
├── Interaction Layer — 鼠标/键盘事件处理
├── Tool System — 调色板工具（选择、形状创建、连接绘制）
├── Model Change Notifier — 监听外部 AADL 模型变更
├── AgeContentOutlinePage — 图表元素树形视图
├── TabbedPropertySheetPage — 属性标签页视图
└── IOperationHistory — 撤销/重做（Eclipse 标准）
```

### 12. 扩展点

| 扩展点 | 用途 |
|--------|------|
| `org.osate.ge.businessObjectHandlers` | 注册自定义 BO Handler |
| `org.osate.ge.businessObjectProviders` | 贡献子业务对象 |
| `org.osate.ge.diagramTypes` | 注册图表类型（Structure, Package, Custom） |
| `org.osate.ge.images` | 注册图片 |
| `org.osate.ge.tools` | 注册自定义调色板工具 |
| `org.osate.ge.contentFilters` | 过滤图中显示的 BO |

### 13. EMV2 与 GE 的集成

```
AADL 文本中 'annex error_model {** ... **}'
    ↓ EMV2AnnexInstantiator
EMV2AnnexInstance (实例模型中)
    ↓ GE errormodel Handler (BusinessObjectProvider)
图表显示错误模型结构
    ↓ GE 渲染流水线
JavaFX 场景图（错误传播可视化）
```

文本与图表的双向同步：
1. AADL 文本变更 → ResourceChangeEvent → ModelChangeNotifier
2. DiagramUpdater 读取更新的 AADL → 更新 BO 树
3. 图表修改事件 → 场景图更新
4. 用户图表编辑 → 模型修改（Handler 实现 deleter/renamer）
