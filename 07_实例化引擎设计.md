# 实例化引擎设计

本文档基于源码分析，深入描述 OSATE2 将声明式 AADL 模型转换为实例模型的实例化引擎。

源码位置：`core/org.osate.aadl2.instantiation/src/org/osate/aadl2/instantiation/`

## 1. 入口与核心流程

### 1.1 入口类：`InstantiateModel`

主要入口方法：
- `buildInstanceModelFile(ComponentImplementation ci)` — 创建实例文件并保存
- `instantiate(ComponentImplementation ci, ...)` — 实例化到已有资源集
- `rebuildInstanceModelFile(IResource)` — 重新生成实例模型
- `rebuildAllInstanceModelFiles(IProgressMonitor)` — 重生成所有实例模型

### 1.2 完整实例化流程

`fillSystemInstance()` 方法（约第 466-526 行）按以下 **严格顺序** 执行：

```
1. populateComponentInstance(root, 0)
   ├── fillModes() — 创建模式实例（必须最先）
   ├── instantiateSubcomponents() — 递归实例化子组件
   ├── instantiateFeatures() — 创建特征实例
   ├── fillModeTransitions() — 创建模式转换
   └── instantiateFlowSpecs() — 创建流规格实例

2. createSystemOperationModes(root, somLimit)
   └── 枚举所有有效的系统操作模式组合

3. CreateConnectionsSwitch.processPreOrderAll(root)
   └── 创建所有连接实例

4. ValidateConnectionsSwitch.processPreOrderAll(root)
   └── 验证连接语义正确性

5. CreateEndToEndFlowsSwitch.processPreOrderAll(root)
   └── 创建端到端流实例

6. 属性缓存（两阶段）
   ├── CacheContainedPropertyAssociationsSwitch.processPostOrderAll()
   └── CachePropertyAssociationsSwitch.processPreOrderAll()

7. processConnections(ci)
   └── 处理 Connection_Set/Connection_Pattern 属性

8. AnnexInstantiationController.instantiateAllAnnexes(root)
   └── 委托各注册的 Annex 实例化器
```

## 2. 关键类职责

| 类 | 字节数 | 职责 |
|---|--------|-----|
| **InstantiateModel** | 93,664 | 主编排器，管理整个实例化生命周期 |
| **CreateConnectionsSwitch** | 70,693 | 连接实例创建，多段路径追踪 |
| **CreateEndToEndFlowsSwitch** | 42,787 | 端到端流实例化 |
| **ValidateConnectionsSwitch** | 27,274 | 连接类型检查、方向验证 |
| **CachePropertyAssociationsSwitch** | 15,952 | 属性求值与缓存 |
| **CacheContainedPropertyAssociationsSwitch** | 15,956 | Contained 属性缓存 |
| **ConnectionInfo** | 15,214 | 连接遍历状态跟踪 |
| **CheckInstanceSemanticsSwitch** | 12,500 | 语义检查 |
| **SCProperties** | 3,406 | 语义连接属性多级缓存 |
| **AnnexInstantiationController** | 4,648 | Annex 实例化委托 |

所有 Switch 类继承自 `AadlProcessingSwitchWithProgress`，使用 EMF Switch 模式遍历模型树。

## 3. 组件树构建

### 3.1 模式实例化（最先执行）

必须最先创建，因为：
- 子组件通过 `inModes` 引用模式
- 派生模式(Derived Mode)需要父模式引用
- 模式转换需要模式实例已存在

### 3.2 子组件实例化

```
instantiateSubcomponents():
  for each subcomponent in getAllSubcomponents():
    处理数组维度（ArrayInstantiator 递归嵌套）
    检测循环包含（安全检查）
    为每个数组元素创建 ComponentInstance
    递归调用 populateComponentInstance()
```

### 3.3 特征实例化

```
instantiateFeatures():
  for each feature in getAllFeatures():
    创建 FeatureInstance
    处理特征数组（维度限制检查）
    解析特征原型到类别（Data_Port, Event_Port 等）
    如果是 FeatureGroup，递归展开子特征
```

## 4. 连接实例化（最复杂的部分）

连接实例化是一个**多阶段、多段追踪**的过程，是整个实例化引擎最复杂的部分。

### 4.1 连接起点发现

`CreateConnectionsSwitch` 前序遍历实例树，从以下类型组件的特征出发：
- 连接终止类别组件：THREAD, PROCESSOR, DEVICE, BUS, VIRTUAL_BUS, VIRTUAL_PROCESSOR
- SystemInstance 的外部端口

### 4.2 多段连接追踪

```
appendSegment(connInfo, newSegment, ci, goOpposite):
  1. 确定当前段的源端和目的端
  2. 处理 FeatureGroup 层次导航
  3. 处理双向连接（可能反向追踪）
  4. 跟踪 upFeature/downFeature 栈
  5. 创建 ConnectionInstanceEnd
  6. 到达最终目标时创建完整 ConnectionInstance
```

### 4.3 ConnectionInfo 状态跟踪

```java
ConnectionInfo {
    kind: ConnectionKind;          // PORT, PARAMETER, ACCESS, FEATURE_GROUP
    connections: List<Connection>;  // 路径上的声明式连接列表
    opposites: List<Boolean>;       // 每段是否反向追踪
    sources/destinations: List<ConnectionInstanceEnd>;
    bidirectional: boolean;         // 整条路径是否双向
    across: boolean;                // AADL 2.2 的"across"连接
}
```

### 4.4 连接验证

`ValidateConnectionsSwitch` 验证每个连接实例：
- 类型兼容性检查
- 方向一致性（端口、访问、参数）
- 标记有多个连接的数据端口（错误条件）

### 4.5 连接模式处理

实例化后处理 `Connection_Set` 和 `Connection_Pattern` 属性：
- 支持模式：One_To_One, One_To_All, All_To_One, All_To_All, Next, Previous, Cyclic_Next 等
- 根据模式展开数组连接，为每个模式匹配创建新 ConnectionInstance

## 5. 系统操作模式(SOM)枚举

### 5.1 SOM 创建算法

```
使用嵌套 State/Node 类的层次枚举：

enumerateSoms():  // 递归深度优先
    for each modal component in hierarchy:
        if parent mode active:
            for each active mode in this component:
                递归枚举剩余组件
        else:
            跳过模式，枚举剩余
```

### 5.2 SOM 限制

- 通过项目首选项 `PREF_SOM_LIMIT` 配置
- 防止模式组合的组合爆炸
- 超出限制时返回 -1

### 5.3 Mode2SOM 映射

`HashMap<ModeInstance, Set<SystemOperationMode>>` 跟踪每个 ModeInstance 出现在哪些 SOM 中，用于模式特定的属性求值。

## 6. 属性传播与缓存

### 6.1 两阶段属性缓存

**阶段1：Contained 属性（后序遍历）**
- 缓存通过 `applies to` 子句定义的属性
- 处理语义连接上的属性
- 存储在 `SCProperties` 多级 Map 中：
  ```
  Map<ConnectionInstance, Map<Property, Map<Connection, PropertyAssociation>>>
  ```

**阶段2：常规属性（前序遍历）**
- 为每个实例求值属性表达式
- 创建 PropertyAssociationInstance
- 处理模式特定属性（不同模式下不同值）
- 解析属性引用到具体值

### 6.2 属性定义过滤

使用 `getAllUsedPropertyDefinitions()` 而非 `getAllPropertyDefinitions()`，扫描实际使用来构建过滤集，显著提升性能。

## 7. Annex 实例化

```java
AnnexInstantiationController.instantiateAllAnnexes(root):
    通过 AnnexInstantiatorRegistry 发现注册的 Annex 实例化器
    对每个 Annex 类型执行独立遍历
    例如：EMV2AnnexInstantiator 处理错误模型
```

## 8. 错误处理策略

### 8.1 错误收集

- 使用 `QueuingAnalysisErrorReporter` 在构建期间收集错误
- 完成后过滤：只保留仍在最终实例模型中的元素的错误
- 转发到原始错误管理器

### 8.2 典型错误场景

| 错误类型 | 处理方式 |
|---------|---------|
| `RootMissingException` | 重建时根组件不存在 |
| 循环包含 | 检测并报错 |
| 缺失分类器 | 警告 |
| 连接类型不匹配 | 错误标记 |
| 数据端口多连接 | 错误标记 |
| 数组大小不匹配 | 错误标记 |

## 9. 性能优化

| 优化技术 | 说明 |
|---------|------|
| **Classifier 缓存** | `HashMap<InstanceObject, InstantiatedClassifier>` 避免重复原型解析 |
| **特征数组跳过** | 仅处理特征数组的第一个元素 |
| **SOM 限制** | 防止组合爆炸 |
| **属性定义过滤** | 仅处理实际使用的属性 |
| **延迟连接模式处理** | 所有连接实例化后才处理模式 |
| **单次资源保存** | 实例化结束后统一保存 |
| **进度监视器** | 支持取消长时间操作 |

## 10. 实例化数据流总结

```
声明式模型                               实例模型
==========                               ========
AadlPackage
└── PackageSection
    ├── ComponentType
    │   ├── Feature[]           ──→      FeatureInstance[]
    │   └── FlowSpecification[] ──→      FlowSpecificationInstance[]
    │
    └── ComponentImplementation
        ├── Subcomponent[]      ──→      ComponentInstance[] (递归树)
        ├── Connection[]        ──→      ConnectionInstance[] (端到端)
        ├── FlowImplementation[]         (合并到流实例)
        ├── EndToEndFlow[]      ──→      EndToEndFlowInstance[]
        └── Mode[]              ──→      ModeInstance[]
                                         SystemOperationMode[] (枚举组合)
```
