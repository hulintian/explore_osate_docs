# 分析框架设计

本文档基于源码分析，描述 OSATE2 的分析框架架构——分析如何被触发、执行和报告结果。

## 1. Handler 类层次

OSATE2 分析框架使用多级继承层次：

```
org.eclipse.core.commands.AbstractHandler
└── AbstractAaxlHandler (org.osate.ui.handlers)
    │   管理属性引用初始化、错误报告、CSV日志
    │   抽象方法: doAaxlAction(IProgressMonitor, Element)
    │
    └── AaxlReadOnlyHandlerAsJob
        │   将分析包装在 WorkspaceJob 中（后台线程安全执行）
        │   锁定整个工作空间确保独占访问
        │
        ├── AbstractInstanceOrDeclarativeModelReadOnlyHandler
        │   │   支持声明式和实例模型双模式分析
        │   │   管理 SOM 选择和迭代
        │   │
        │   └── AbstractInstanceOrDeclarativeModelModifyHandler
        │       │   添加修改跟踪，自动保存资源
        │       │
        │       └── CheckFlowLatency (具体分析)
        │
        └── AbstractAnalysisHandler
            │   现代批处理模式，并行分析多个实例文件
            │   在 reports/ 子目录生成输出
            │
            └── NewBusLoadAnalysisHandler 等
```

## 2. 分析触发流程

### 2.1 UI 注册（plugin.xml）

每个分析通过 Eclipse 扩展点注册：

```xml
<!-- 1. 定义命令 -->
<extension point="org.eclipse.ui.commands">
  <category id="org.osate.analysis.category" name="Analysis"/>
  <command categoryId="org.osate.analysis.category"
           id="org.osate.analysis.flows.checkFlowLatency"
           name="Check Flow Latency"/>
</extension>

<!-- 2. 绑定 Handler + 启用条件 -->
<extension point="org.eclipse.ui.handlers">
  <handler class="org.osate.analysis.flows.handlers.CheckFlowLatency"
           commandId="org.osate.analysis.flows.checkFlowLatency">
    <enabledWhen>
      <reference definitionId="org.osate.ui.definition.isInstanceFileOrSystemInstanceSelected"/>
    </enabledWhen>
  </handler>
</extension>

<!-- 3. 放置到菜单 -->
<extension point="org.eclipse.ui.menus">
  <menuContribution locationURI="menu:org.osate.ui.analysisMenu?after=core">
    <command commandId="org.osate.analysis.flows.checkFlowLatency"/>
  </menuContribution>
</extension>

<!-- 4. 定义 Marker 类型 -->
<extension id="FlowLatencyObjectMarker" point="org.eclipse.core.resources.markers">
  <super type="org.osate.aadl2.modelsupport.AadlObjectMarker"/>
  <persistent value="true"/>
</extension>
```

### 2.2 完整执行流程

```
用户选择实例文件 → UI 检查启用条件
    ↓
handler.execute(ExecutionEvent)         [UI 线程]
    ↓
创建 WorkspaceJob（获取工作空间锁）
    ↓
Job.schedule()                          [后台线程]
    ↓
actionBody():
  ├── initPropertyReferences()          // 查找需要的属性定义
  ├── initializeAnalysis()              // 可选：弹出参数对话框
  │
  ├── FOR EACH SystemOperationMode:
  │   ├── si.setCurrentSystemOperationMode(som)
  │   ├── analyzeInstanceModel(monitor, errManager, si, som)
  │   └── si.clearCurrentSystemOperationMode()
  │
  └── finalizeAnalysis()                // 保存报告，生成 Markers
```

## 3. 结果报告框架

### 3.1 Result 元模型

定义在 `core/org.osate.results/model/result.ecore`：

```
AnalysisResult (根容器)
├── analysis: String              — 分析名称
├── message: String               — 总体消息
├── modelElement → EObject        — 被分析的元素引用
├── parameters: ObjectValue[]     — 分析参数
├── results: Result[]             — 顶层结果（常每个 SOM 一个）
├── diagnostics: Diagnostic[]     — 顶层问题
└── resultType: ResultType        — TBD | SUCCESS | FAILURE | ERROR

Result (层次结果节点)
├── message: String
├── modelElement → EObject
├── values: Value[]               — 分析数值结果
├── diagnostics: Diagnostic[]     — 此节点的问题
├── subResults: Result[]          — 嵌套结果
└── resultType: ResultType

Diagnostic (问题/消息)
├── diagnosticType: DiagnosticType — ERROR | WARNING | INFO | TBD
├── message: String
└── modelElement → EObject

Value (多态值类型)
├── IntegerValue (long + unit)
├── RealValue (double + unit)
├── StringValue, BooleanValue
├── EObjectValue, ObjectValue
```

### 3.2 ResultUtil 工具方法

```java
// 创建结果结构
ResultUtil.createAnalysisResult(name, target)
ResultUtil.createResult(msg, target, type)

// 创建诊断
ResultUtil.createErrorDiagnostic(msg, target)
ResultUtil.createWarningDiagnostic(msg, target)
ResultUtil.createInfoDiagnostic(msg, target)

// 添加值
ResultUtil.addIntegerValue(result, value, unit)
ResultUtil.addRealValue(result, value, unit)
ResultUtil.addStringValue(result, value)
```

## 4. 属性读取模式

### 4.1 Handler 属性初始化

```java
@Override
protected void initPropertyReferences() {
    latencyProperty = lookupPropertyDefinition("Timing_Properties", "Latency");
    periodProperty = lookupPropertyDefinition("Timing_Properties", "Period");
    // 缺失的属性记录在 notFound 列表中
    // 如有缺失且未抑制，分析不会运行
}
```

### 4.2 分析时属性访问

```java
// 实例模型上的属性值
PropertyExpression pe = PropertyUtils.getSimplePropertyValue(component, property);
long value = PropertyUtils.getIntegerValue(component, property, defaultVal);
double time = PropertyUtils.getScaledNumberValue(component, property, TimeUnits.MS);
```

## 5. 流延迟分析算法（典型分析示例）

`FlowLatencyAnalysisSwitch` 是最复杂的内置分析之一：

### 5.1 执行入口

```java
FlowLatencyAnalysisSwitch.invokeOnSOM(SystemInstance, SystemOperationMode, options)
  → 创建 LatencyReport
  → 遍历所有 EndToEndFlowInstance
```

### 5.2 分析过程

```
1. 流发现：迭代所有 EndToEndFlowInstance
2. 流分解：分解为 FlowSpecificationInstance + ConnectionInstance 段
3. 组件延迟计算：
   ├── 读取 timing 属性
   ├── 读取 dispatch protocol (periodic/aperiodic/sporadic)
   └── 根据组件类型和优先级计算执行延迟
4. 连接延迟计算：
   ├── 遍历绑定查找传输介质(bus)
   ├── 读取传输时间属性
   └── 计算排队延迟
5. 模式特定计算：按 SOM 调整
6. 聚合：
   ├── 求和所有流元素延迟
   ├── 计算最佳/最坏路径
   └── 生成 LatencyReportEntry
```

### 5.3 关键数据结构

```
LatencyReport
└── LatencyReportEntry (per ETEFInstance + SOM)
    └── LatencyContributor[]
        ├── LatencyContributorComponent — 组件延迟详情
        └── LatencyContributorConnection — 连接延迟详情
```

### 5.4 报告生成

```
LatencyReport.finalizeAllEntries()
  → 为每个 LatencyReportEntry 创建 Result
  → 添加最佳/最坏延迟 Value
  → 为每个贡献者创建嵌套 Result
  → 为问题创建 Diagnostic
  → 可选：CSV/Excel 导出
```

## 6. 结果呈现渠道

| 渠道 | 实现方式 |
|------|---------|
| **Eclipse Markers** | 主渠道。分析特定 Marker 类型 → Problems 视图 + 编辑器注解 |
| **CSV/Excel 报告** | 在 `reports/<analysisType>/` 子目录生成详细数据 |
| **对话框通知** | 完成/错误对话框（通过 `Display.asyncExec()`） |
| **Result 对象树** | 可序列化为 XMI，供下游工具使用 |

### Marker 生成流程

```java
generateMarkers(analysisResult, errManager):
  for each Result in analysisResult.getResults():
    for each Diagnostic in result.getDiagnostics():
      switch (diagnostic.getDiagnosticType()):
        ERROR   → errManager.error(element, message)
        WARNING → errManager.warning(element, message)
        INFO    → errManager.info(element, message)
      // → MarkerAnalysisErrorReporter 创建 Eclipse IMarker
```

## 7. 跨分析通用模式

### 模式1：实例模型 SOM 迭代

```java
for (SystemOperationMode som : selectedSOMs) {
    si.setCurrentSystemOperationMode(som);
    analyzeInstanceModel(monitor, errManager, si, som);
    si.clearCurrentSystemOperationMode();
}
```

### 模式2：属性初始化门控

```java
initPropertyReferences() 中查找所有需要的属性
→ 缺失属性记录在 notFound
→ 如有缺失，doAaxlAction() 不执行
```

### 模式3：批处理（AbstractAnalysisHandler）

```java
execute():
  KickoffJob 发现选中的所有 .aaxl 文件
  → 创建输出文件夹
  → 为每个文件启动并行 AnalysisJob
    └── Job 创建 AnalysisResult → 生成 Markers
```

## 8. 添加新分析的扩展模式

### 简单分析 Handler 模板

```java
public class MyAnalysisHandler
    extends AbstractInstanceOrDeclarativeModelModifyHandler {

  @Override
  protected String getActionName() { return "My Analysis"; }

  @Override
  protected boolean canAnalyzeDeclarativeModels() { return false; }

  @Override
  protected void analyzeInstanceModel(IProgressMonitor monitor,
      AnalysisErrorReporterManager errManager,
      SystemInstance root, SystemOperationMode som) {
    AnalysisResult result = ResultUtil.createAnalysisResult("My Analysis", root);
    // ... 分析逻辑 ...
    generateMarkers(result, errManager);
  }

  @Override
  public String getMarkerType() {
    return "com.example.MyAnalysisMarker";
  }
}
```

### 需要注册的扩展点

1. `org.eclipse.ui.commands` — 命令定义
2. `org.eclipse.ui.handlers` — Handler 绑定 + 启用条件
3. `org.eclipse.ui.menus` — 菜单位置
4. `org.eclipse.core.resources.markers` — Marker 类型
5. `org.osate.pluginsupport.registeredjavaclasses` — 可选，暴露给外部调用
